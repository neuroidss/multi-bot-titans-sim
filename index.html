<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Multi-Bot Titans Sim v5.17 - EEG/Hallucinate</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <style>
        :root {
             --bg-color: #f0f2f5; --container-bg: #ffffff; --border-color: #d9d9d9;
             --text-color: #333; --primary-color: #1890ff; --primary-hover: #40a9ff;
             --secondary-color: #faad14; --secondary-hover: #ffc53d;
             --danger-color: #f5222d; --danger-hover: #ff4d4f;
             --success-color: #52c41a; --success-hover: #73d13d;
             --info-color: #13c2c2; --info-hover: #36cfc9;
             --warn-color: #fa8c16; --frozen-color: #40a9ff;
             --hallucinating-color: #722ed1; --param-label-color: #0050b3;
             --player-color: var(--success-color); --player-controlled-color: var(--success-color);
             --hardcoded-color: var(--primary-color); --learning-color: var(--danger-color);
             --learning-available-color: #ff7a45; --mobile-button-bg: #f0f0f0;
             --mobile-button-border: #ccc; --mobile-button-active-bg: #e0e0e0;
             --target-indicator-bg: rgba(255, 255, 0, 0.7); --target-crosshair-color: rgba(255, 0, 0, 0.7);
             --chat-bg: #f8f9fa; --chat-border: #e9ecef; --chat-text: #495057;
        }
        html, body { height: 100%; margin: 0; padding: 0; overflow-x: hidden; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"; display: flex; flex-direction: column; align-items: center; padding: 10px; box-sizing: border-box; line-height: 1.5; background-color: var(--bg-color); color: var(--text-color); -webkit-tap-highlight-color: transparent; }
        canvas { border: 1px solid var(--border-color); margin-bottom: 10px; display: block; max-width: 100%; height: auto; touch-action: manipulation; background-color: var(--container-bg); cursor: crosshair; image-rendering: pixelated; }
        .main-container { display: flex; flex-direction: row; flex-wrap: wrap; align-items: flex-start; width: 100%; max-width: 1700px; justify-content: center; gap: 25px; padding-bottom: 150px; }
        .grid-container { flex-basis: 600px; flex-grow: 1; max-width: 800px; min-width: 300px; display: flex; flex-direction: column; justify-content: flex-start; align-items: center; }
        .controls-and-info { display: flex; flex-direction: column; flex-basis: 480px; flex-grow: 1; min-width: 320px; max-width: 700px; background-color: var(--container-bg); padding: 15px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .simulation-controls, .param-controls, .player-controls { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 15px; align-items: center; }
        button { padding: 8px 14px; cursor: pointer; border: none; border-radius: 5px; font-size: 0.9em; font-weight: 500; transition: background-color 0.2s ease, box-shadow 0.2s ease; }
        button:hover:not(:disabled) { box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        button:active:not(:disabled) { transform: translateY(1px); box-shadow: none; }
        button:disabled { background-color: #bdc3c7 !important; cursor: not-allowed; opacity: 0.6; box-shadow: none; }

        #startButton { background-color: var(--success-color); color: white; } #startButton:hover:not(:disabled) { background-color: var(--success-hover); }
        #stopButton { background-color: var(--danger-color); color: white; } #stopButton:hover:not(:disabled) { background-color: var(--danger-hover); }
        #resetRoundButton, #resetFullButton { background-color: var(--secondary-color); color: white; } #resetRoundButton:hover:not(:disabled), #resetFullButton:hover:not(:disabled) { background-color: var(--secondary-hover); }
        #applyParamsButton { background-color: #722ed1; color: white; } #applyParamsButton:hover:not(:disabled) { background-color: #9254de; }
        #saveParamsButton, #loadParamsButton, #resetParamsButton { background-color: var(--info-color); font-size: 0.85em; padding: 6px 10px; color: white;} #saveParamsButton:hover:not(:disabled), #loadParamsButton:hover:not(:disabled), #resetParamsButton:hover:not(:disabled) { background-color: var(--info-hover); }
        #joinButton { background-color: var(--primary-color); color: white; margin-left: auto; }
        #leaveButton { background-color: var(--warn-color); color: white; margin-left: auto; display: none; } #leaveButton:hover:not(:disabled) { background-color: #ffc53d; }

        .parameters { border: 1px solid #eee; padding: 15px; margin-bottom: 15px; background-color: #fdfdfd; border-radius: 5px; max-height: 45vh; overflow-y: auto; }
        .parameters h3 { margin-top: 0; margin-bottom: 15px; font-size: 1.1em; border-bottom: 1px solid #eee; padding-bottom: 8px; color: #444; }
        .parameters div.param-item { margin-bottom: 10px; display: flex; flex-wrap: wrap; align-items: center; gap: 5px 10px; font-size: 0.88em; }
        .parameters label { display: inline-block; min-width: 200px; font-weight: 500; flex-shrink: 0; color: #555; }
        .parameters input[type=number], .parameters input[type=text], .parameters input[type=checkbox], .parameters select { padding: 5px 7px; box-sizing: border-box; border: 1px solid var(--border-color); border-radius: 4px; font-size: 1em; background-color: #fff; }
        .parameters input[type=number], .parameters input[type=text], .parameters select { width: 100px; }
        .parameters input[type=range] { flex-grow: 1; cursor: pointer; } .parameters .range-value { font-weight: bold; min-width: 40px; text-align: right; } .parameters input[type=checkbox] { width: auto; margin-left: 5px; transform: scale(1.1); }
        .parameters .tooltip { display: inline-block; background-color: #bfbfbf; border-radius: 50%; width: 16px; height: 16px; text-align: center; line-height: 16px; font-size: 11px; color: white; font-weight: bold; vertical-align: middle; cursor: help; position: relative; margin-left: 3px; }
        .parameters .reset-hint { font-style: italic; font-size: 0.85em; color: var(--warn-color); margin-left: 6px; display: none; white-space: nowrap; font-weight: 500; }
        .parameters div.param-item.changed label { color: var(--warn-color); font-weight: bold;}
        .parameters div.param-item.needs-reset .reset-hint { display: inline !important; }
        .tooltip .tooltiptext { visibility: hidden; width: 220px; background-color: rgba(0,0,0,0.8); color: #fff; text-align: center; border-radius: 6px; padding: 8px; position: absolute; z-index: 10; bottom: 130%; left: 50%; margin-left: -110px; opacity: 0; transition: opacity 0.3s; font-size: 0.85em; font-weight: normal; line-height: 1.3; box-shadow: 0 2px 5px rgba(0,0,0,0.3); }
        .tooltip:hover .tooltiptext, .tooltip:focus .tooltiptext, .tooltip:active .tooltiptext { visibility: visible; opacity: 1; }

        .info { display: flex; flex-direction: column; gap: 10px; margin-top: 15px; }
        .bot-type-info { border: 1px solid #e8e8e8; padding: 10px; font-size: 0.88em; background-color: #fafafa; border-radius: 5px; }
        .bot-type-info b { display: block; margin-bottom: 4px; font-size: 1.05em; }
        .stats { margin-top: 15px; font-weight: bold; padding: 12px; background-color: #e6f7ff; border: 1px solid #bae7ff; border-radius: 5px; font-size: 0.95em; line-height: 1.5; }
        .status-tag { font-weight: bold; border: 1px dashed; padding: 1px 4px; border-radius: 4px; display: inline-block; font-size: 0.8em; margin-left: 4px; }
        .frozen-status { color: var(--frozen-color); border-color: var(--frozen-color); background-color: #e6f7ff; }
        .hallucinating-status { color: var(--hallucinating-color); border-color: var(--hallucinating-color); background-color: #f9f0ff; }
        hr { width: 100%; margin: 20px 0; border: 0; border-top: 1px solid #e8e8e8; }

        .library-param-label { font-weight: bold; color: var(--param-label-color); }
        .param-group { border: 1px dashed #e0e0e0; padding: 12px; margin-bottom: 12px; border-radius: 4px; background-color: #fdfdfd;}
        .param-group h4 { margin-top: 0; margin-bottom: 10px; font-size: 1em; color: #666; }
        #status, #round-info, #player-info { margin-top: 8px; font-weight: bold; }
        #status { font-size: 1.05em; color: #333; min-height: 1.4em; }
        #round-info { font-size: 0.95em; color: #555;}
        #player-info { font-size: 0.9em; color: var(--player-color); margin-bottom: 8px; }
        #connection-status { position: fixed; top: 5px; right: 8px; font-size: 0.8em; padding: 3px 6px; border-radius: 4px; background-color: var(--danger-color); color: white; font-weight: bold; z-index: 1000; box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
        #connection-status.connected { background-color: var(--success-color); }

        .hc-color { color: var(--hardcoded-color); font-weight: bold;}
        .ln-color { color: var(--learning-color); font-weight: bold;}
        .pl-color { color: var(--player-color); font-weight: bold;}
        .player-controlled-marker { font-weight: bold; color: var(--player-controlled-color); margin-left: 5px; font-size: 0.9em; }
        .learning-available-marker { outline: 2px dashed var(--learning-available-color); outline-offset: 2px; cursor: pointer; }

        #target-indicator { position: fixed; top: 5px; left: 8px; font-size: 0.85em; padding: 4px 8px; border-radius: 4px; background-color: var(--target-indicator-bg); color: #333; font-weight: bold; z-index: 1000; box-shadow: 0 1px 3px rgba(0,0,0,0.2); display: none; }

        #chat-container { margin-top: 15px; width: 100%; background-color: var(--chat-bg); border: 1px solid var(--chat-border); border-radius: 5px; padding: 10px; box-sizing: border-box; height: 200px; overflow-y: scroll; font-size: 0.85em; color: var(--chat-text); }
        .chat-message { margin-bottom: 5px; padding-bottom: 5px; border-bottom: 1px dotted #eee; }
        .chat-message strong { margin-right: 5px; }

        #mobile-controls { position: fixed; bottom: 0; left: 0; width: 100%; background-color: rgba(230, 230, 230, 0.9); padding: 8px 3px; box-sizing: border-box; display: none; flex-direction: row; justify-content: space-around; align-items: center; z-index: 900; border-top: 1px solid var(--border-color); box-shadow: 0 -2px 5px rgba(0,0,0,0.1); touch-action: manipulation; -webkit-user-select: none; user-select: none; pointer-events: none; opacity: 0.7; }
        #mobile-controls.enabled { pointer-events: auto; opacity: 1.0; }
        #mobile-controls button { font-size: 16px; padding: 10px 8px; min-width: 50px; text-align: center; background-color: var(--mobile-button-bg); border: 1px solid var(--mobile-button-border); border-radius: 8px; font-weight: bold; color: var(--text-color); flex-grow: 1; margin: 0 2px; }
        #mobile-controls.enabled button:active { background-color: var(--mobile-button-active-bg); transform: scale(0.95); }

        @media (max-width: 768px) {
            #mobile-controls { display: flex; }
            .main-container { padding-bottom: 80px; }
            .grid-container { min-width: unset; width: 100%; max-width: 100%; flex-basis: auto; }
            .controls-and-info { min-width: unset; width: 100%; max-width: 100%; flex-basis: auto; margin-top:15px; }
             .parameters label { min-width: 160px; } .parameters { max-height: 35vh; }
             .desktop-only { display: none; }
        }
        @media (min-width: 769px) {
            #mobile-controls { display: none; }
        }

    </style>
</head>
<body>
    <h1>Multi-Bot Titans Sim (v5.17 - EEG/Hallucinate)</h1>
    <p style="max-width: 900px; text-align: center; margin-bottom: 15px; font-size: 0.95em;">
        Bots navigate, claim goals, punch, or use mental attacks. Tap/Click grid to set target for player bot.
        <span class="ln-color">Learning Bots (Red)</span>, <span class="hc-color">Hardcoded Bots (Blue)</span>, <span class="pl-color">Players (Green)</span>. Check Bot Chat below.
    </p>
     <p style="font-size:0.85em; color: var(--danger-color);"><i>Backend (`server.py`) must be running. Requires PyTorch, MNE, etc. Check server console for status.</i></p>
    <div id="connection-status" title="Connection Status">Connecting...</div>
    <div id="target-indicator">Target: None</div>

    <div class="main-container">
        <div class="grid-container">
            <canvas id="gridCanvas" width="600" height="600"></canvas>
             <div id="player-info">Player Bot ID: None</div>
             <p style="font-size: 0.85em; margin-top: 5px;" class="desktop-only">Controls: Click/Drag on grid to set target. Click self to cancel. Click available Learning Bot or Join button.</p>
        </div>

        <div class="controls-and-info">
             <div class="simulation-controls">
                <button id="startButton" title="Start Simulation" disabled>Start</button>
                <button id="stopButton" disabled title="Stop Simulation">Stop</button>
                <button id="resetRoundButton" title="Start a New Round" disabled>New Round</button>
                <button id="resetFullButton" title="Reset Environment and Learning State" disabled>Reset All</button>
                 <button id="joinButton" title="Join as Player" disabled>Join Game</button>
                 <button id="leaveButton" title="Relinquish Control" disabled>Leave Bot</button>
             </div>
                 <div id="status" style="margin-bottom: 5px;">Status: Connecting...</div>
                 <div id="round-info" style="margin-bottom: 15px;">Round: 0</div>
            <hr>
            <div class="parameters">
                 <h3>Simulation Parameters</h3>
                 <div class="param-group">
                    <h4>General</h4>
                    <div data-param="SIMULATION_SPEED_MS" class="param-item"><label for="param-SIMULATION_SPEED_MS">Sim Speed (ms delay):</label><input type="number" id="param-SIMULATION_SPEED_MS" name="SIMULATION_SPEED_MS" min="1" max="2000" step="10"><span class="tooltip" tabindex="0">?<span class="tooltiptext">Target delay between server steps. (Apply)</span></span><span class="reset-hint"></span></div>
                    <div data-param="FREEZE_DURATION" class="param-item"><label for="param-FREEZE_DURATION">Punch Freeze (steps):</label><input type="number" id="param-FREEZE_DURATION" name="FREEZE_DURATION" min="1" max="100"><span class="tooltip" tabindex="0">?<span class="tooltiptext">Steps bots stay frozen after punch. (Apply)</span></span><span class="reset-hint"></span></div>
                    <div data-param="MENTAL_ATTACK_RANGE" class="param-item needs-reset"><label for="param-MENTAL_ATTACK_RANGE">Mental Attack Range:</label><input type="number" id="param-MENTAL_ATTACK_RANGE" name="MENTAL_ATTACK_RANGE" min="1" max="50"><span class="tooltip" tabindex="0">?<span class="tooltiptext">Range of mental attack. (NewRound Req.)</span></span><span class="reset-hint">(Reset Req.)</span></div>
                    <div data-param="MENTAL_ATTACK_DURATION" class="param-item needs-reset"><label for="param-MENTAL_ATTACK_DURATION">Mental Attack Duration:</label><input type="number" id="param-MENTAL_ATTACK_DURATION" name="MENTAL_ATTACK_DURATION" min="1" max="500"><span class="tooltip" tabindex="0">?<span class="tooltiptext">Duration of mental attack effect. (NewRound Req.)</span></span><span class="reset-hint">(Reset Req.)</span></div>
                    <div data-param="NUM_ACTIONS" class="param-item needs-reset"><label for="param-NUM_ACTIONS">Number of Actions:</label><input type="number" id="param-NUM_ACTIONS" name="NUM_ACTIONS" min="4" max="10" readonly><span class="tooltip" tabindex="0">?<span class="tooltiptext">Total actions available (Up,Down,L,R,Punch,Claim,MAtt). (ResetAll Req. Readonly in UI).</span></span><span class="reset-hint">(Reset Req.)</span></div>
                </div>
                 <div class="param-group">
                     <h4>AV Output</h4>
                     <div data-param="ENABLE_AV" class="param-item needs-reset"><label for="param-ENABLE_AV">Enable AV Processing:</label><input type="checkbox" id="param-ENABLE_AV" name="ENABLE_AV"><span class="tooltip" tabindex="0">?<span class="tooltiptext">Enable backend processing of bot data for audio/visuals. (ResetAll Req.)</span></span><span class="reset-hint">(Reset Req.)</span></div>
                     <div data-param="ENABLE_AV_OUTPUT" class="param-item needs-reset"><label for="param-ENABLE_AV_OUTPUT">Enable AV Output:</label><input type="checkbox" id="param-ENABLE_AV_OUTPUT" name="ENABLE_AV_OUTPUT"><span class="tooltip" tabindex="0">?<span class="tooltiptext">Enables SoundDevice audio and visualization window (VisPy/Matplotlib) or web stream. (ResetAll Req.)</span></span><span class="reset-hint">(Reset Req.)</span></div>
                     <div data-param="VISUALIZATION_MODE" class="param-item needs-reset"><label for="param-VISUALIZATION_MODE">Visualization Mode:</label><select id="param-VISUALIZATION_MODE" name="VISUALIZATION_MODE"><option value="vispy">VisPy (3D)</option><option value="matplotlib">Matplotlib (3D)</option><option value="web">Web Stream</option><option value="none">None</option></select><span class="tooltip" tabindex="0">?<span class="tooltiptext">Selects visualization backend. 'Web' streams to /visuals. (ResetAll Req.)</span></span><span class="reset-hint">(Reset Req.)</span></div>
                 </div>
                 <div class="param-group">
                     <h4>Environment (Reset Req.)</h4>
                     <div data-param="GRID_SIZE" class="param-item needs-reset"><label for="param-GRID_SIZE">Grid Size:</label><input type="number" id="param-GRID_SIZE" name="GRID_SIZE" min="10" max="200"><span class="tooltip" tabindex="0">?<span class="tooltiptext">Width/Height of the grid. (ResetAll Req.)</span></span><span class="reset-hint">(Reset Req.)</span></div>
                     <div data-param="NUM_GOALS" class="param-item needs-reset"><label for="param-NUM_GOALS">Num Goals:</label><input type="number" id="param-NUM_GOALS" name="NUM_GOALS" min="0" max="500"><span class="tooltip" tabindex="0">?<span class="tooltiptext">Number of goals. (ResetAll Req.)</span></span><span class="reset-hint">(Reset Req.)</span></div>
                     <div data-param="NUM_HC_BOTS" class="param-item needs-reset"><label for="param-NUM_HC_BOTS">Num Hardcoded Bots:</label><input type="number" id="param-NUM_HC_BOTS" name="NUM_HC_BOTS" min="0" max="100"><span class="tooltip" tabindex="0">?<span class="tooltiptext">Number of rule-based bots. (ResetAll Req.)</span></span><span class="reset-hint">(Reset Req.)</span></div>
                     <div data-param="NUM_LEARNING_BOTS" class="param-item needs-reset"><label for="param-NUM_LEARNING_BOTS">Num Learning Bots:</label><input type="number" id="param-NUM_LEARNING_BOTS" name="NUM_LEARNING_BOTS" min="0" max="100"><span class="tooltip" tabindex="0">?<span class="tooltiptext">Number of HNS learning bots. (ResetAll Req.)</span></span><span class="reset-hint">(Reset Req.)</span></div>
                     <div data-param="MAX_STEPS_PER_ROUND" class="param-item needs-reset"><label for="param-MAX_STEPS_PER_ROUND">Max Steps/Round:</label><input type="number" id="param-MAX_STEPS_PER_ROUND" name="MAX_STEPS_PER_ROUND" min="100" max="10000"><span class="tooltip" tabindex="0">?<span class="tooltiptext">Max steps before round ends. (NewRound Req.)</span></span><span class="reset-hint">(Reset Req.)</span></div>
                     <div data-param="VISIBILITY_RANGE" class="param-item needs-reset"><label for="param-VISIBILITY_RANGE">Sense Visibility Range:</label><input type="number" id="param-VISIBILITY_RANGE" name="VISIBILITY_RANGE" min="2" max="50"><span class="tooltip" tabindex="0">?<span class="tooltiptext">How far bots 'see'. (NewRound Req.)</span></span><span class="reset-hint">(Reset Req.)</span></div>
                     <div data-param="RANDOMIZE_ENV_PER_ROUND" class="param-item"><label for="param-RANDOMIZE_ENV_PER_ROUND">New Env Each Round:</label><input type="checkbox" id="param-RANDOMIZE_ENV_PER_ROUND" name="RANDOMIZE_ENV_PER_ROUND"><span class="tooltip" tabindex="0">?<span class="tooltiptext">If checked, 'New Round' generates new layout. (Apply)</span></span><span class="reset-hint"></span></div>
                 </div>
                 <div class="param-group">
                     <h4>Learning Bot Behavior (Apply Req.)</h4>
                     <div data-param="LEARNING_BOT_BASE_EXPLORATION_RATE" class="param-item"><label for="param-LEARNING_BOT_BASE_EXPLORATION_RATE">Base Explore Rate (%):</label><input type="number" id="param-LEARNING_BOT_BASE_EXPLORATION_RATE" name="LEARNING_BOT_BASE_EXPLORATION_RATE" min="0" max="100" step="1"><span class="tooltip" tabindex="0">?<span class="tooltiptext">Base chance Learning Bot explores. (Apply)</span></span><span class="reset-hint"></span></div>
                     <div data-param="LEARNING_BOT_RULE_EXPLORE_PERCENT" class="param-item"><label for="param-LEARNING_BOT_RULE_EXPLORE_PERCENT">Rule Exploration (%):</label><input type="number" id="param-LEARNING_BOT_RULE_EXPLORE_PERCENT" name="LEARNING_BOT_RULE_EXPLORE_PERCENT" min="0" max="100" step="1"><span class="tooltip" tabindex="0">?<span class="tooltiptext">Of explore actions, % using rules. (Apply)</span></span><span class="reset-hint"></span></div>
                     <div data-param="PLAYER_CONTROL_PERCENT" class="param-item"><label for="param-PLAYER_CONTROL_PERCENT">Player Control Influence (%):</label><input type="range" id="param-PLAYER_CONTROL_PERCENT" name="PLAYER_CONTROL_PERCENT" min="0" max="100" step="1"><span class="range-value" id="value-PLAYER_CONTROL_PERCENT">100%</span><span class="tooltip" tabindex="0">?<span class="tooltiptext">How much player input overrides AI. (Apply)</span></span><span class="reset-hint"></span></div>
                     <div data-param="MENTAL_ATTACK_USES_RECONSTRUCTION" class="param-item"><label for="param-MENTAL_ATTACK_USES_RECONSTRUCTION">Hallucinate via Reconstruction:</label><input type="checkbox" id="param-MENTAL_ATTACK_USES_RECONSTRUCTION" name="MENTAL_ATTACK_USES_RECONSTRUCTION"><span class="tooltip" tabindex="0">?<span class="tooltiptext">If true, mental attack uses L0 reconstruction as senses. (Apply)</span></span><span class="reset-hint"></span></div>
                     <div data-param="USE_RULES_AS_HNS_INPUT" class="param-item needs-reset"><label for="param-USE_RULES_AS_HNS_INPUT">Feed Rules to HNS:</label><input type="checkbox" id="param-USE_RULES_AS_HNS_INPUT" name="USE_RULES_AS_HNS_INPUT"><span class="tooltip" tabindex="0">?<span class="tooltiptext">Provide hardcoded action suggestion as HNS input. (ResetAll Req.)</span></span><span class="reset-hint">(Reset Req.)</span></div>
                 </div>
                 <div class="param-group">
                     <h4>EEG Settings (Reset Req.)</h4>
                     <div data-param="EEG_SETTINGS.enabled" class="param-item needs-reset"><label for="param-EEG_SETTINGS.enabled">Enable EEG Input:</label><input type="checkbox" id="param-EEG_SETTINGS.enabled" name="EEG_SETTINGS.enabled"><span class="tooltip" tabindex="0">?<span class="tooltiptext">Enable processing and use of EEG features. (ResetAll Req.)</span></span><span class="reset-hint">(Reset Req.)</span></div>
                     <div data-param="EEG_SETTINGS.simulate_eeg" class="param-item"><label for="param-EEG_SETTINGS.simulate_eeg">Simulate EEG Data:</label><input type="checkbox" id="param-EEG_SETTINGS.simulate_eeg" name="EEG_SETTINGS.simulate_eeg"><span class="tooltip" tabindex="0">?<span class="tooltiptext">If true, server generates random EEG data. (Apply)</span></span><span class="reset-hint"></span></div>
                     <div data-param="EEG_SETTINGS.sfreq" class="param-item needs-reset"><label for="param-EEG_SETTINGS.sfreq">EEG Sample Rate (Hz):</label><input type="number" id="param-EEG_SETTINGS.sfreq" name="EEG_SETTINGS.sfreq" min="10" max="1000"><span class="tooltip" tabindex="0">?<span class="tooltiptext">Sample frequency of EEG data. (ResetAll Req.)</span></span><span class="reset-hint">(Reset Req.)</span></div>
                     <div data-param="EEG_SETTINGS.processing_window_samples" class="param-item needs-reset"><label for="param-EEG_SETTINGS.processing_window_samples">EEG Window (Samples):</label><input type="number" id="param-EEG_SETTINGS.processing_window_samples" name="EEG_SETTINGS.processing_window_samples" min="50" max="2000"><span class="tooltip" tabindex="0">?<span class="tooltiptext">Analysis window length for features. (ResetAll Req.)</span></span><span class="reset-hint">(Reset Req.)</span></div>
                     <div data-param="EEG_SETTINGS.processing_interval_new_samples" class="param-item needs-reset"><label for="param-EEG_SETTINGS.processing_interval_new_samples">EEG Update Interval (Samples):</label><input type="number" id="param-EEG_SETTINGS.processing_interval_new_samples" name="EEG_SETTINGS.processing_interval_new_samples" min="10" max="1000"><span class="tooltip" tabindex="0">?<span class="tooltiptext">New samples to trigger recalculation. (ResetAll Req.)</span></span><span class="reset-hint">(Reset Req.)</span></div>
                     <div data-param="EEG_SETTINGS.processing_config.coherence.enable" class="param-item needs-reset"><label for="param-EEG_SETTINGS.processing_config.coherence.enable">Enable Coherence Feat:</label><input type="checkbox" id="param-EEG_SETTINGS.processing_config.coherence.enable" name="EEG_SETTINGS.processing_config.coherence.enable"><span class="tooltip" tabindex="0">?<span class="tooltiptext">Calculate coherence features (requires MNE-Connectivity). (ResetAll Req.)</span></span><span class="reset-hint">(Reset Req.)</span></div>
                 </div>

                 <hr>
                 <div class="param-controls">
                    <button id="applyParamsButton" title="Send Changed Parameters to Server" disabled>Apply Changes</button>
                    <button id="saveParamsButton" title="Save Current UI Parameters to Browser Storage">Save Params</button>
                    <button id="loadParamsButton" title="Load Parameters from Browser Storage">Load Params</button>
                    <button id="resetParamsButton" title="Reset UI Parameters to Default Values">Reset UI to Default</button>
                 </div>
            </div>

             <div class="stats">
                Goals Claimed (Total):<br>
                <span class="hc-color">Hardcoded:</span> <span id="hc-total-goals">0</span> |
                <span class="ln-color">Learning</span>/<span class="pl-color">Player:</span> <span id="learning-total-goals">0</span><br>
                Avg Bot Anomaly (Learning): <span id="learning-avg-anomaly">N/A</span>
            </div>

            <div class="info">
                <div id="bots-info-container" style="max-height: 250px; overflow-y: auto; border: 1px solid #f0f0f0; padding: 5px; background: #fff;">
                     <div class="bot-type-info"><b>Bots Information Loading...</b></div>
                </div>
            </div>
            <div id="chat-container">
                 <div style="font-weight: bold; margin-bottom: 5px; border-bottom: 1px solid #ccc; padding-bottom: 3px;">Bot Chat Log:</div>
            </div>
        </div>
    </div>

    <div id="mobile-controls">
        <button id="btn-up">▲</button>
        <button id="btn-left">◀</button>
        <button id="btn-right">▶</button>
        <button id="btn-down">▼</button>
        <button id="btn-punch">Punch</button>
        <button id="btn-claim">Claim</button>
        <button id="btn-mental-attack">MAtt</button>
    </div>

    <script>
        let socket;
        const canvas = document.getElementById('gridCanvas');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');
        const roundInfoEl = document.getElementById('round-info');
        const playerInfoEl = document.getElementById('player-info');
        const connectionStatusEl = document.getElementById('connection-status');
        const gridContainerEl = document.querySelector('.grid-container');
        const botsInfoContainerEl = document.getElementById('bots-info-container');
        const mobileControlsEl = document.getElementById('mobile-controls');
        const targetIndicatorEl = document.getElementById('target-indicator');
        const chatContainerEl = document.getElementById('chat-container');

        const paramInputs = {}; const paramItems = {}; const rangeValueDisplays = {};
        document.querySelectorAll('.parameters .param-item').forEach(paramItemDiv => {
            const key = paramItemDiv.dataset.param; const input = paramItemDiv.querySelector('input, select');
            if (key && input && paramItemDiv) {
                paramInputs[key] = input; paramItems[key] = paramItemDiv;
                input.addEventListener('input', () => handleParamInputChange(key)); input.addEventListener('change', () => handleParamInputChange(key));
                 if (input.type === 'range') { const valueDisplay = paramItemDiv.querySelector('.range-value'); if (valueDisplay) { rangeValueDisplays[key] = valueDisplay; valueDisplay.textContent = `${input.value}%`; input.addEventListener('input', () => { valueDisplay.textContent = `${input.value}%`; });}}
            }
        });
        function handleParamInputChange(key) { markParamChanged(key); }

        const startButton = document.getElementById('startButton'); const stopButton = document.getElementById('stopButton');
        const resetRoundButton = document.getElementById('resetRoundButton'); const resetFullButton = document.getElementById('resetFullButton');
        const applyParamsButton = document.getElementById('applyParamsButton'); const saveParamsButton = document.getElementById('saveParamsButton');
        const loadParamsButton = document.getElementById('loadParamsButton'); const resetParamsButton = document.getElementById('resetParamsButton');
        const joinButton = document.getElementById('joinButton'); const leaveButton = document.getElementById('leaveButton');
        const mobileUp = document.getElementById('btn-up'); const mobileLeft = document.getElementById('btn-left'); const mobileRight = document.getElementById('btn-right');
        const mobileDown = document.getElementById('btn-down'); const mobilePunch = document.getElementById('btn-punch');
        const mobileClaim = document.getElementById('btn-claim'); const mobileMentalAttack = document.getElementById('btn-mental-attack');

        let serverConfig = {}; let uiDefaults = {};
        let clientState = { environment: null, bots: {}, round: 0, stats: { hc_total_goals: 0, learning_total_goals: 0 }, isRunning: false, needsFullReset: false, needsRoundReset: false, playerBotId: null, playerOriginalBotId: null, playerTarget: null };
        let visualizer = null; const LOCAL_STORAGE_KEY_UI = 'multiBotSimParams_v5.17_EEG'; const LOCAL_STORAGE_KEY_PLAYER = 'multiBotPlayerControl_v5.17';
        let isDragging = false; let lastSentTargetTime = 0; const TARGET_UPDATE_INTERVAL_MS = 100; const MAX_CHAT_MESSAGES = 100;

        function getNestedValue(obj, path) { return path.split('.').reduce((value, key) => (value && value[key] !== undefined) ? value[key] : null, obj); }
        function setNestedValue(obj, path, value) { const keys = path.split('.'); let current = obj; for (let i = 0; i < keys.length - 1; i++) { if (current[keys[i]] === undefined || typeof current[keys[i]] !== 'object') { current[keys[i]] = {}; } current = current[keys[i]]; } current[keys[keys.length - 1]] = value; }

        class Visualizer {
            constructor(canvasCtx, gridContainer) { this.ctx = canvasCtx; this.canvas = canvasCtx.canvas; this.gridContainer = gridContainer; this.gridSize = 0; this.cellSize = 0; this.currentGoals = []; this.currentObstacles = new Set(); this.claimedGoalsIDs = new Set(); this.lastContainerWidth = 0; this.ctx.imageSmoothingEnabled = false; }
            updateGridDimensions(newGridSize) { if (!this.gridContainer || newGridSize === undefined || newGridSize <= 0) return; const gridSizeNum = Number(newGridSize); if (isNaN(gridSizeNum) || gridSizeNum <= 0) return; const availableWidth = Math.max(300, this.gridContainer.offsetWidth - 2); const newCellSize = Math.max(4, Math.floor(availableWidth / gridSizeNum)); if (gridSizeNum !== this.gridSize || newCellSize !== this.cellSize || this.gridContainer.offsetWidth !== this.lastContainerWidth) { this.gridSize = gridSizeNum; this.cellSize = newCellSize; this.canvas.width = this.gridSize * this.cellSize; this.canvas.height = this.gridSize * this.cellSize; this.lastContainerWidth = this.gridContainer.offsetWidth;}}
            updateData(environmentState) { if (!environmentState) return; this.updateGridDimensions(environmentState.size); this.currentGoals = environmentState.goals || []; this.currentObstacles = new Set((environmentState.obstacles || []).map(obs => `${obs[0]},${obs[1]}`)); this.claimedGoalsIDs = new Set(environmentState.claimedGoals || []); }
            drawGrid() { if (!this.ctx || !this.gridSize || !this.cellSize) return; const canvasWidth = this.canvas.width; const canvasHeight = this.canvas.height; this.ctx.clearRect(0, 0, canvasWidth, canvasHeight); this.ctx.fillStyle = '#ffffff'; this.ctx.fillRect(0, 0, canvasWidth, canvasHeight); if (this.cellSize > 5) { this.ctx.strokeStyle = '#f0f0f0'; this.ctx.lineWidth = 1; for (let i = 0; i <= this.gridSize; i++) { const pos = Math.round(i * this.cellSize) + 0.5; this.ctx.beginPath(); this.ctx.moveTo(pos, 0); this.ctx.lineTo(pos, canvasHeight); this.ctx.stroke(); this.ctx.beginPath(); this.ctx.moveTo(0, pos); this.ctx.lineTo(canvasWidth, pos); this.ctx.stroke(); } } else { this.ctx.strokeStyle = '#e0e0e0'; this.ctx.lineWidth = 0.5; this.ctx.strokeRect(0.5, 0.5, canvasWidth - 1, canvasHeight - 1); } this.ctx.fillStyle = '#595959'; this.currentObstacles.forEach(obsString => { try { const [x, y] = obsString.split(',').map(Number); if(x>=0 && x<this.gridSize && y>=0 && y<this.gridSize) { this.ctx.fillRect(Math.floor(x * this.cellSize), Math.floor(y * this.cellSize), Math.ceil(this.cellSize), Math.ceil(this.cellSize)); } } catch(e){}}); this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'middle'; const goalRadius = Math.max(1.5, this.cellSize * 0.35); const goalFontSize = Math.max(7, Math.floor(this.cellSize * 0.5)); this.currentGoals.forEach((goal) => { if(!goal || goal.x === undefined) return; const drawX = Math.floor(goal.x * this.cellSize); const drawY = Math.floor(goal.y * this.cellSize); const centerX = drawX + this.cellSize / 2; const centerY = drawY + this.cellSize / 2; if(goal.x>=0 && goal.x<this.gridSize && goal.y>=0 && goal.y<this.gridSize) { if (this.claimedGoalsIDs.has(goal.id)) { this.ctx.fillStyle = '#d9d9d9'; this.ctx.fillRect(drawX, drawY, Math.ceil(this.cellSize), Math.ceil(this.cellSize)); if (this.cellSize > 8) { this.ctx.fillStyle = '#8c8c8c'; this.ctx.font = `bold ${goalFontSize}px sans-serif`; this.ctx.fillText("X", centerX, centerY); } } else { this.ctx.fillStyle = 'gold'; this.ctx.beginPath(); this.ctx.arc(centerX, centerY, goalRadius, 0, Math.PI * 2); this.ctx.fill(); if (this.cellSize > 4) { this.ctx.strokeStyle = '#d48806'; this.ctx.lineWidth = 0.5; this.ctx.stroke(); } if (this.cellSize > 10) { this.ctx.fillStyle = '#434343'; this.ctx.font = `bold ${goalFontSize*0.8}px sans-serif`; this.ctx.fillText("G", centerX, centerY + 1); } } } }); this.ctx.lineWidth = 1; }
             drawBot(bot) { if (!bot || !bot.pos || bot.pos.x === undefined) return; const drawX = bot.pos.x * this.cellSize; const drawY = bot.pos.y * this.cellSize; const centerX = drawX + this.cellSize / 2; const centerY = drawY + this.cellSize / 2; const radius = Math.max(2, this.cellSize * 0.4); let color = '#888'; let isAvailableToJoin = false; if (bot.type === 'Hardcoded') { color = getComputedStyle(document.documentElement).getPropertyValue('--hardcoded-color').trim() || '#1890ff'; } else if (bot.type === 'Learning') { if (bot.is_player) { color = getComputedStyle(document.documentElement).getPropertyValue('--player-controlled-color').trim() || '#52c41a'; } else { color = getComputedStyle(document.documentElement).getPropertyValue('--learning-color').trim() || '#f5222d'; if (clientState.playerBotId === null) { isAvailableToJoin = true; } } }
                 this.ctx.fillStyle = color; this.ctx.globalAlpha = bot.is_hallucinating ? 0.5 : 0.95; this.ctx.beginPath(); this.ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI); this.ctx.fill();
                 if (bot.is_player) { this.ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--player-controlled-color').trim(); this.ctx.lineWidth = Math.max(1.5, Math.floor(this.cellSize * 0.15)); this.ctx.setLineDash([Math.max(1, this.cellSize * 0.1), Math.max(1, this.cellSize * 0.1)]); this.ctx.stroke(); this.ctx.setLineDash([]); } else if (isAvailableToJoin) { this.ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--learning-available-color').trim(); this.ctx.lineWidth = Math.max(1.5, Math.floor(this.cellSize * 0.1)); this.ctx.setLineDash([Math.max(2, this.cellSize * 0.15), Math.max(1, this.cellSize * 0.1)]); this.ctx.strokeRect(drawX + this.ctx.lineWidth / 2, drawY + this.ctx.lineWidth / 2, this.cellSize - this.ctx.lineWidth, this.cellSize - this.ctx.lineWidth); this.ctx.setLineDash([]); }
                 if (bot.freezeTimer > 0) { this.ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--frozen-color').trim(); this.ctx.lineWidth = Math.max(1.5, Math.floor(this.cellSize * 0.1)); this.ctx.globalAlpha = 0.8; this.ctx.beginPath(); this.ctx.arc(centerX, centerY, radius * 1.15, 0, 2 * Math.PI); this.ctx.stroke(); }
                 if (bot.is_hallucinating) { this.ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--hallucinating-color').trim(); this.ctx.lineWidth = Math.max(1.5, Math.floor(this.cellSize * 0.1)); this.ctx.globalAlpha = 0.7; this.ctx.beginPath(); this.ctx.arc(centerX, centerY, radius * 0.7, 0, 2 * Math.PI); this.ctx.stroke(); }
                 this.ctx.globalAlpha = 1.0; if (this.cellSize > 14) { this.ctx.fillStyle = 'white'; this.ctx.font = `bold ${Math.max(6, Math.floor(this.cellSize * 0.35))}px sans-serif`; const idNum = bot.id.match(/\d+/); const label = bot.id[0] + (idNum ? idNum[0] : ''); this.ctx.fillText(label, centerX, centerY + 1); } this.ctx.lineWidth = 1;
             }
             drawTarget(targetCoord) { if (!targetCoord || !this.cellSize || targetCoord.x === null || targetCoord.y === null) return; const centerX = targetCoord.x * this.cellSize + this.cellSize / 2; const centerY = targetCoord.y * this.cellSize + this.cellSize / 2; const crossSize = this.cellSize * 0.4; this.ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--target-crosshair-color').trim(); this.ctx.lineWidth = Math.max(1, this.cellSize * 0.08); this.ctx.globalAlpha = 0.8; this.ctx.beginPath(); this.ctx.moveTo(centerX - crossSize, centerY); this.ctx.lineTo(centerX + crossSize, centerY); this.ctx.moveTo(centerX, centerY - crossSize); this.ctx.lineTo(centerX, centerY + crossSize); this.ctx.stroke(); this.ctx.globalAlpha = 1.0; this.ctx.lineWidth = 1; }
            update(state) { if (!state) return; this.updateData(state.environment); this.drawGrid(); Object.values(state.bots || {}).forEach(bot => this.drawBot(bot)); if (clientState.playerBotId && clientState.playerTarget) { this.drawTarget(clientState.playerTarget); } }
            getBotAtCoord(gridX, gridY) { for (const botId in clientState.bots) { const bot = clientState.bots[botId]; if (bot.pos && bot.pos.x === gridX && bot.pos.y === gridY) { return bot; } } return null; }
        }

        function setupSocket() {
            try { const socketUrl = window.location.origin; socket = io(socketUrl, { reconnectionAttempts: 5, transports: ['websocket'] });
                socket.on('connect', () => { connectionStatusEl.textContent = 'Connected'; connectionStatusEl.classList.add('connected'); statusEl.textContent = "Status: Connected. Waiting for state..."; const savedPlayer = localStorage.getItem(LOCAL_STORAGE_KEY_PLAYER); if (savedPlayer) { try { const playerData = JSON.parse(savedPlayer); if (playerData && playerData.originalBotId) { socket.emit('rejoin_game', { originalBotId: playerData.originalBotId }); } else { localStorage.removeItem(LOCAL_STORAGE_KEY_PLAYER); } } catch (e) { localStorage.removeItem(LOCAL_STORAGE_KEY_PLAYER); } } });
                socket.on('disconnect', (reason) => { connectionStatusEl.textContent = 'Disconnected'; connectionStatusEl.classList.remove('connected'); statusEl.textContent = `Status: Disconnected (${reason}).`; clientState.isRunning = false; clientState.playerTarget = null; updateTargetIndicator(); updateButtonStates(); updateMobileControls(); disableAllControls(); });
                socket.on('connect_error', (err) => { connectionStatusEl.textContent = 'Connection Error'; connectionStatusEl.classList.remove('connected'); statusEl.textContent = "Status: Connection Error."; clientState.isRunning = false; clientState.playerTarget = null; updateTargetIndicator(); disableAllControls(); });
                socket.on('initial_state', (state) => { if (!visualizer) visualizer = new Visualizer(ctx, gridContainerEl); serverConfig = copyConfig(state.config || {}); uiDefaults = copyConfig(state.config || {}); updateUIFromConfig(serverConfig); updateClientState(state); markParamsApplied(); clientState.isRunning = state.isRunning !== undefined ? state.isRunning : false; visualizer.update(clientState); updateInfoPanel(); updateButtonStates(); updateMobileControls(); statusEl.textContent = `Status: ${clientState.isRunning ? 'Running...' : 'Ready'}`; checkForNeededResets(); });
                socket.on('update_state', (state) => { updateClientState(state); if (visualizer) visualizer.update(clientState); updateInfoPanel(); });
                socket.on('config_update', (config) => { serverConfig = copyConfig(config || {}); uiDefaults = copyConfig(serverConfig); updateUIFromConfig(serverConfig); markParamsApplied(); clearResetHints(); statusEl.textContent = "Status: Config Updated by Server."; updateButtonStates(); updateMobileControls(); });
                socket.on('status_update', (data) => { statusEl.textContent = `Status: ${data.message}`; });
                socket.on('simulation_started', () => { clientState.isRunning = true; statusEl.textContent = "Status: Running..."; updateButtonStates(); updateMobileControls(); clearResetHints(); });
                socket.on('simulation_stopped', (data) => { clientState.isRunning = false; statusEl.textContent = `Status: ${data.message || 'Stopped.'}`; clientState.playerTarget = null; updateTargetIndicator(); updateButtonStates(); updateMobileControls(); checkForNeededResets(); });
                socket.on('config_update_ack', (data) => { if (data.success) { serverConfig = copyConfig(data.updated_config || serverConfig); updateUIFromConfig(serverConfig); clientState.needsFullReset = data.needs_full_reset; clientState.needsRoundReset = data.needs_round_reset; markParamsApplied(); updateButtonStates(); updateMobileControls(); let msg = "Parameters Applied."; if(clientState.needsFullReset) msg += " 'Reset All' required."; else if(clientState.needsRoundReset) msg += " 'New Round' or 'Reset All' required."; statusEl.textContent = `Status: ${msg}`; } else { alert(`Failed to apply parameters: ${data.message || 'Unknown error'}`); statusEl.textContent = `Status: Parameter Apply Failed.`; } });
                socket.on('join_ack', (data) => { if(data.success) { clientState.playerBotId = data.player_id; clientState.playerOriginalBotId = data.original_bot_id; playerInfoEl.textContent = `CONTROLLING BOT: ${clientState.playerBotId}`; localStorage.setItem(LOCAL_STORAGE_KEY_PLAYER, JSON.stringify({ originalBotId: data.original_bot_id })); statusEl.textContent = `Status: Joined, controlling ${clientState.playerBotId}.`; clientState.playerTarget = null; updateTargetIndicator(); } else { alert(`Failed to join: ${data.message}`); playerInfoEl.textContent = `Player Bot ID: None`; localStorage.removeItem(LOCAL_STORAGE_KEY_PLAYER); } updateButtonStates(); updateMobileControls(); });
                socket.on('rejoin_ack', (data) => { if(data.success) { clientState.playerBotId = data.player_id; clientState.playerOriginalBotId = data.original_bot_id; playerInfoEl.textContent = `CONTROLLING BOT: ${clientState.playerBotId}`; localStorage.setItem(LOCAL_STORAGE_KEY_PLAYER, JSON.stringify({ originalBotId: data.original_bot_id })); statusEl.textContent = `Status: Rejoined, controlling ${clientState.playerBotId}.`; clientState.playerTarget = null; updateTargetIndicator(); } else { playerInfoEl.textContent = `Player Bot ID: None`; localStorage.removeItem(LOCAL_STORAGE_KEY_PLAYER); } updateButtonStates(); updateMobileControls(); });
                socket.on('leave_ack', (data) => { if(data.success) { clientState.playerBotId = null; clientState.playerOriginalBotId = null; playerInfoEl.textContent = 'Player Bot ID: None'; localStorage.removeItem(LOCAL_STORAGE_KEY_PLAYER); clientState.playerTarget = null; updateTargetIndicator(); statusEl.textContent = `Status: Left bot control.`; } else { alert(`Failed to leave: ${data.message}`); } updateButtonStates(); updateMobileControls(); });
                socket.on('player_joined', (data) => { updateInfoPanel(); updateButtonStates(); updateMobileControls(); });
                socket.on('player_left', (data) => { if (clientState.playerBotId === data.player_id) { clientState.playerBotId = null; clientState.playerOriginalBotId = null; playerInfoEl.textContent = 'Player Bot ID: None'; localStorage.removeItem(LOCAL_STORAGE_KEY_PLAYER); clientState.playerTarget = null; updateTargetIndicator(); } updateButtonStates(); updateMobileControls(); updateInfoPanel(); });
                socket.on('bot_chat', (data) => { addChatMessage(data.bot_id, data.message); });
            } catch (e) { connectionStatusEl.textContent = 'JS Error'; statusEl.textContent = "Status: Error initializing connection."; alert("Could not initialize connection."); }
        }

        function updateClientState(newState) { if(!newState) return; if (newState.environment) clientState.environment = newState.environment; if (newState.bots) { clientState.bots = newState.bots; if (clientState.playerBotId && clientState.bots[clientState.playerBotId]) { clientState.playerTarget = clientState.bots[clientState.playerBotId].target_coord || null; } else { if (clientState.playerBotId) { clientState.playerBotId = null; clientState.playerOriginalBotId = null; localStorage.removeItem(LOCAL_STORAGE_KEY_PLAYER); playerInfoEl.textContent = 'Player Bot ID: None'; } clientState.playerTarget = null; } updateTargetIndicator(); } if (newState.round !== undefined) clientState.round = newState.round; if (newState.stats) clientState.stats = newState.stats; if (newState.isRunning !== undefined) clientState.isRunning = newState.isRunning; if (newState.config) { serverConfig = copyConfig(newState.config); } updateButtonStates(); updateMobileControls(); }
        function updateInfoPanel() { roundInfoEl.textContent = `Round: ${clientState.round}`; document.getElementById('hc-total-goals').textContent = clientState.stats.hc_total_goals || 0; document.getElementById('learning-total-goals').textContent = clientState.stats.learning_total_goals || 0; let botCounts = { Hardcoded: 0, Learning: 0 }; let botInfoHTML = ''; let totalAnomaly = 0; let learningBotCount = 0; const sortedBotIds = Object.keys(clientState.bots || {}).sort((a, b) => { const typeA = clientState.bots[a]?.type || ''; const typeB = clientState.bots[b]?.type || ''; const isPlayerA = clientState.bots[a]?.is_player || false; const isPlayerB = clientState.bots[b]?.is_player || false; if(isPlayerA && !isPlayerB) return -1; if(!isPlayerA && isPlayerB) return 1; const typeOrder = { 'Learning': 1, 'Hardcoded': 2 }; if(typeOrder[typeA] !== typeOrder[typeB]) return (typeOrder[typeA] || 99) - (typeOrder[typeB] || 99); const numA = parseInt(a.match(/\d+/)?.[0] || '0'); const numB = parseInt(b.match(/\d+/)?.[0] || '0'); return numA - numB; });
             sortedBotIds.forEach(botId => { const bot = clientState.bots[botId]; if (!bot) return; const type = bot.type || 'Unknown'; let typeClass = ''; const isPlayerControlled = bot.is_player || false; if (type === 'Hardcoded') typeClass = 'hc-color'; else if (type === 'Learning') typeClass = isPlayerControlled ? 'pl-color' : 'ln-color'; if(type in botCounts) botCounts[type]++;
                let statusText = "Active"; let statusClasses = "status-tag";
                if (bot.freezeTimer > 0) { statusText = `Frozen (${bot.freezeTimer})`; statusClasses += " frozen-status"; }
                else if (bot.is_hallucinating) { statusText = `Hallucinating (${bot.mental_attack_timer})`; statusClasses += " hallucinating-status"; }
                let anomalyText = ''; if (type === 'Learning' && bot.anomaly !== undefined && bot.anomaly !== null) { totalAnomaly += bot.anomaly; learningBotCount++; anomalyText = ` | Anomaly: ${bot.anomaly.toFixed(4)}`; } const playerMarker = isPlayerControlled ? '<span class="player-controlled-marker">(Player)</span>' : ''; botInfoHTML += `<div class="bot-type-info"><b><span class="${typeClass}">${type} ${bot.id}</span></b>${playerMarker} Pos: (${bot.pos?.x ?? '?', bot.pos?.y ?? '?'}) | Mode: ${bot.mode || 'N/A'} | Status: <span class="${statusClasses}">${statusText}</span> | Goals: ${bot.goals_round || 0} ${anomalyText}</div>`; });
             const avgAnomaly = learningBotCount > 0 ? (totalAnomaly / learningBotCount).toFixed(4) : 'N/A'; document.getElementById('learning-avg-anomaly').textContent = avgAnomaly; botsInfoContainerEl.innerHTML = botInfoHTML || '<div class="bot-type-info"><b>No bots found.</b></div>'; }
        function updateButtonStates() { const connected = socket && socket.connected; const hasChanges = !!document.querySelector('.param-item.changed'); const canJoin = connected && Object.values(clientState.bots || {}).some(b => b.type === 'Learning' && !b.is_player); const isPlayer = clientState.playerBotId !== null; startButton.disabled = !connected || clientState.isRunning || clientState.needsFullReset || clientState.needsRoundReset || hasChanges; stopButton.disabled = !connected || !clientState.isRunning; resetRoundButton.disabled = !connected || clientState.isRunning; resetFullButton.disabled = !connected || clientState.isRunning; applyParamsButton.disabled = !connected || clientState.isRunning || !hasChanges; joinButton.disabled = !connected || isPlayer || !canJoin; joinButton.style.display = 'flex'; leaveButton.disabled = !connected || !isPlayer; leaveButton.style.display = isPlayer ? 'flex' : 'none'; saveParamsButton.disabled = !connected; loadParamsButton.disabled = !connected || clientState.isRunning; resetParamsButton.disabled = !connected || clientState.isRunning;
             const rAllK = ['GRID_SIZE', 'NUM_HC_BOTS', 'NUM_LEARNING_BOTS', 'NUM_GOALS', 'NUM_ACTIONS', 'SENSORY_INPUT_DIM', 'POLICY_HEAD_INPUT_LEVEL_NAME', 'AV_DATA_SOURCE_LEVEL_NAME', 'HIERARCHY_LEVEL_CONFIGS', 'ENABLE_AV', 'ENABLE_AV_OUTPUT', 'VISUALIZATION_MODE', 'EEG_SETTINGS', 'USE_RULES_AS_HNS_INPUT'];
             const rRndK = ['MAX_STEPS_PER_ROUND', 'VISIBILITY_RANGE', 'OBSTACLES_FACTOR_MIN', 'OBSTACLES_FACTOR_MAX', 'MIN_GOAL_START_DISTANCE_FACTOR', 'MIN_BOT_START_DISTANCE_FACTOR', 'MIN_BOT_GOAL_DISTANCE_FACTOR', 'MENTAL_ATTACK_RANGE', 'MENTAL_ATTACK_DURATION'];
             document.querySelectorAll('.param-item').forEach(item => { const key = item.dataset.param; const hintEl = item.querySelector('.reset-hint'); if (!hintEl) return; let needsReset = false; let resetText = ''; if (clientState.needsFullReset && rAllK.some(rk => key.startsWith(rk))) { needsReset = true; resetText = '(Reset All Req.)'; } else if (clientState.needsRoundReset && (rRndK.some(rk => key.startsWith(rk)) || rAllK.some(rk => key.startsWith(rk)))) { needsReset = true; resetText = '(Reset Req.)'; } item.classList.toggle('needs-reset', needsReset); hintEl.style.display = needsReset ? 'inline' : 'none'; hintEl.textContent = resetText; }); }
        function updateMobileControls() { if (clientState.playerBotId && clientState.isRunning) mobileControlsEl.classList.add('enabled'); else mobileControlsEl.classList.remove('enabled'); }
        function disableAllControls() { startButton.disabled = true; stopButton.disabled = true; resetRoundButton.disabled = true; resetFullButton.disabled = true; applyParamsButton.disabled = true; joinButton.disabled = true; leaveButton.disabled = true; loadParamsButton.disabled = true; resetParamsButton.disabled = true; saveParamsButton.disabled = true; updateMobileControls(); }
        function copyConfig(configObj) { try { return JSON.parse(JSON.stringify(configObj || {})); } catch(e) { return {}; } }
        function updateUIFromConfig(configToUse) { if (!configToUse) return; for(const key in paramInputs) { const input = paramInputs[key]; let value = getNestedValue(configToUse, key); if (value === null) { continue; } if (input.readOnly) continue; if (input.type === 'checkbox') { input.checked = Boolean(value); } else if (input.type === 'range') { input.value = Number(value || 0); if (rangeValueDisplays[key]) rangeValueDisplays[key].textContent = `${input.value}%`; } else if (input.tagName === 'SELECT') { input.value = String(value ?? ''); } else if (input.step && input.step.includes('.')) { const decimals = (input.step.split('.')[1] || '').length; if (decimals > 0) value = parseFloat(value || 0).toFixed(decimals); } else { value = String(value ?? ''); } if (input.type !== 'checkbox' && input.type !== 'range' && input.tagName !== 'SELECT') input.value = value; } markParamsApplied(); updateButtonStates(); updateMobileControls(); }
        function getUIConfig() { const config = {}; const baseConfig = Object.keys(serverConfig).length > 0 ? serverConfig : uiDefaults; for(const key in paramInputs) { const input = paramInputs[key]; let value; if (input.readOnly) { value = getNestedValue(baseConfig, key); } else if (input.type === 'checkbox') { value = input.checked; } else { value = input.value; } const defaultValue = getNestedValue(baseConfig, key); const defaultType = defaultValue !== null ? typeof defaultValue : (input.type === 'number' || input.type === 'range' ? 'number' : (input.tagName === 'SELECT' ? 'string' : 'string')); try { if (!input.readOnly && input.type !== 'checkbox' && value === '' && defaultValue !== null) { value = defaultValue; } if (defaultType === 'number' || input.type === 'range') { value = parseFloat(value); if (isNaN(value)) throw new Error("NaN"); if (input.min !== "" && value < parseFloat(input.min)) value = parseFloat(input.min); if (input.max !== "" && value > parseFloat(input.max)) value = parseFloat(input.max); if (input.step && !input.step.includes('.')) { value = Math.round(value); } else if (input.step && input.step.includes('.')) { const decimals = (input.step.split('.')[1] || '').length; if(decimals > 0) value = parseFloat(value.toFixed(decimals)); } } else if (defaultType === 'boolean') { value = input.checked; } else { value = String(value); } setNestedValue(config, key, value); } catch (e) { setNestedValue(config, key, defaultValue); } } return config; }
        function markParamChanged(key) { if(clientState.isRunning) return; const paramItem = paramItems[key]; const input = paramInputs[key]; if (!paramItem || !input || !serverConfig || input.readOnly) return; const uiConf = getUIConfig(); const uiValue = getNestedValue(uiConf, key); const serverValue = getNestedValue(serverConfig, key); let isDifferent = false; if (serverValue === null && uiValue !== null) { isDifferent = true; } else if (typeof uiValue === 'number' && typeof serverValue === 'number') { isDifferent = Math.abs(uiValue - serverValue) > 1e-9; } else { isDifferent = String(uiValue) !== String(serverValue); } if (isDifferent) { paramItem.classList.add('changed'); } else { paramItem.classList.remove('changed'); } updateButtonStates(); updateMobileControls(); }
        function markParamsApplied() { document.querySelectorAll('.param-item.changed').forEach(el => el.classList.remove('changed')); updateButtonStates(); updateMobileControls(); }
        function clearResetHints() { clientState.needsFullReset = false; clientState.needsRoundReset = false; updateButtonStates(); updateMobileControls(); }
        function checkForNeededResets() { if(clientState.isRunning) return; const uiConfig = getUIConfig(); let needsF = false; let needsR = false;
            const rAllK = ['GRID_SIZE', 'NUM_HC_BOTS', 'NUM_LEARNING_BOTS', 'NUM_GOALS', 'NUM_ACTIONS', 'SENSORY_INPUT_DIM', 'POLICY_HEAD_INPUT_LEVEL_NAME', 'AV_DATA_SOURCE_LEVEL_NAME', 'HIERARCHY_LEVEL_CONFIGS', 'ENABLE_AV', 'ENABLE_AV_OUTPUT', 'VISUALIZATION_MODE', 'EEG_SETTINGS', 'USE_RULES_AS_HNS_INPUT'];
            const rRndK = ['MAX_STEPS_PER_ROUND', 'VISIBILITY_RANGE', 'OBSTACLES_FACTOR_MIN', 'OBSTACLES_FACTOR_MAX', 'MIN_GOAL_START_DISTANCE_FACTOR', 'MIN_BOT_START_DISTANCE_FACTOR', 'MIN_BOT_GOAL_DISTANCE_FACTOR', 'MENTAL_ATTACK_RANGE', 'MENTAL_ATTACK_DURATION'];
            let hasAnyChanges = false; for(const key in paramInputs) { if (!paramInputs[key]?.readOnly) { const uiVal = getNestedValue(uiConfig, key); const srvVal = getNestedValue(serverConfig, key); let different = false; if (srvVal === null && uiVal !== null) different = true; else if (typeof uiVal === 'number' && typeof srvVal === 'number') different = Math.abs(uiVal - srvVal) > 1e-9; else different = String(uiVal) !== String(srvVal); const item = paramItems[key]; if(different) { hasAnyChanges = true; if(item) item.classList.add('changed'); if (rAllK.some(rk => key.startsWith(rk))) needsF = true; else if (rRndK.some(rk => key.startsWith(rk))) needsR = true; } else { if(item) item.classList.remove('changed'); } } } clientState.needsFullReset = needsF; clientState.needsRoundReset = needsR || needsF; updateButtonStates(); updateMobileControls(); }
        function saveParamsToLocalStorage() { try { const uiConf = getUIConfig(); localStorage.setItem(LOCAL_STORAGE_KEY_UI, JSON.stringify(uiConf)); alert('UI Parameters saved!'); } catch (e) { alert('Error saving UI parameters.'); } }
        function loadParamsFromLocalStorage() { if(clientState.isRunning) { alert("Stop simulation first."); return; } try { const saved = localStorage.getItem(LOCAL_STORAGE_KEY_UI); if (saved) { const parsed = JSON.parse(saved); updateUIFromConfig(parsed); markParamsApplied(); statusEl.textContent = "Status: UI Params Loaded."; checkForNeededResets(); alert('UI Parameters loaded. Review & Apply/Reset if needed.'); } else alert('No saved UI parameters found.'); } catch (e) { alert('Error loading UI parameters.'); } }
        function resetParamsToDefault() { if(clientState.isRunning) { alert("Stop simulation first."); return; } const baseConfig = Object.keys(uiDefaults).length > 0 ? uiDefaults : copyConfig(DEFAULT_CONFIG); updateUIFromConfig(baseConfig); markParamsApplied(); statusEl.textContent = "Status: UI Reset to Default."; checkForNeededResets(); }
        function updateTargetIndicator() { if (clientState.playerTarget && clientState.playerBotId) { targetIndicatorEl.textContent = `Target: (${clientState.playerTarget.x}, ${clientState.playerTarget.y})`; targetIndicatorEl.style.display = 'block'; } else { targetIndicatorEl.textContent = 'Target: None'; targetIndicatorEl.style.display = 'none'; } }
        function sendTargetUpdate(targetCoord) { const now = Date.now(); if (isDragging && lastSentTargetTime && now - lastSentTargetTime < TARGET_UPDATE_INTERVAL_MS) return; if (socket && socket.connected && clientState.playerBotId) { const currentTarget = clientState.playerTarget; const changed = (targetCoord === null && currentTarget !== null) || (targetCoord !== null && currentTarget === null) || (targetCoord !== null && currentTarget !== null && (targetCoord.x !== currentTarget.x || targetCoord.y !== currentTarget.y)); if (changed) { socket.emit('update_player_target', { target: targetCoord }); clientState.playerTarget = targetCoord; updateTargetIndicator(); if (isDragging) lastSentTargetTime = now; } } }
        function handleCanvasInteraction(event) { if (!socket || !socket.connected || !visualizer || !visualizer.cellSize) return; event.preventDefault(); const rect = canvas.getBoundingClientRect(); let clientX, clientY; if (event.type.startsWith('touch')) { if (event.type === 'touchend' && event.changedTouches.length > 0) { clientX = event.changedTouches[0].clientX; clientY = event.changedTouches[0].clientY; } else if (event.type === 'touchmove' && event.touches.length > 0) { clientX = event.touches[0].clientX; clientY = event.touches[0].clientY; } else if (event.type === 'touchstart' && event.touches.length > 0) { clientX = event.touches[0].clientX; clientY = event.touches[0].clientY; } else { return; } } else { clientX = event.clientX; clientY = event.clientY; } const canvasX = clientX - rect.left; const canvasY = clientY - rect.top; const targetGridX = Math.floor(canvasX / visualizer.cellSize); const targetGridY = Math.floor(canvasY / visualizer.cellSize); if (targetGridX < 0 || targetGridX >= visualizer.gridSize || targetGridY < 0 || targetGridY >= visualizer.gridSize) { if (isDragging) isDragging = false; return; } if (clientState.playerBotId) { const playerBot = clientState.bots[clientState.playerBotId]; if (!playerBot) { clientState.playerBotId = null; clientState.playerOriginalBotId = null; localStorage.removeItem(LOCAL_STORAGE_KEY_PLAYER); return; } if (targetGridX === playerBot.pos.x && targetGridY === playerBot.pos.y && (event.type === 'mouseup' || event.type === 'touchend')) { sendTargetUpdate(null); } else { sendTargetUpdate({ x: targetGridX, y: targetGridY }); } } else { if (event.type === 'mouseup' || event.type === 'touchend') { const clickedBot = visualizer.getBotAtCoord(targetGridX, targetGridY); if (clickedBot && clickedBot.type === 'Learning' && !clickedBot.is_player) { socket.emit('join_game', { target_bot_id: clickedBot.id }); } } } }
        canvas.addEventListener('mousedown', (e) => { isDragging = true; handleCanvasInteraction(e); }); canvas.addEventListener('mousemove', (e) => { if (isDragging) { handleCanvasInteraction(e); } }); canvas.addEventListener('mouseup', (e) => { handleCanvasInteraction(e); isDragging = false; }); canvas.addEventListener('mouseleave', () => { isDragging = false; }); canvas.addEventListener('touchstart', (e) => { isDragging = true; handleCanvasInteraction(e); }, { passive: false }); canvas.addEventListener('touchmove', (e) => { if (isDragging) { handleCanvasInteraction(e); } }, { passive: false }); canvas.addEventListener('touchend', (e) => { handleCanvasInteraction(e); isDragging = false; }, { passive: false }); canvas.addEventListener('touchcancel', () => { isDragging = false; });
        const addMobileButtonListener = (button, actionCode) => { if (button) { const sendAction = (e) => { if(!mobileControlsEl.classList.contains('enabled')) return; e.preventDefault(); sendPlayerAction(actionCode); }; button.addEventListener('touchstart', sendAction, { passive: false }); button.addEventListener('click', sendAction); } };
        function sendPlayerAction(actionCode) { if (clientState.playerBotId && clientState.isRunning && socket && socket.connected) { socket.emit('player_action', { action: actionCode }); } }
        addMobileButtonListener(mobileUp, 0); addMobileButtonListener(mobileLeft, 1); addMobileButtonListener(mobileRight, 2); addMobileButtonListener(mobileDown, 3); addMobileButtonListener(mobilePunch, 4); addMobileButtonListener(mobileClaim, 5); addMobileButtonListener(mobileMentalAttack, 6);
        function setupButtonListeners() { startButton.addEventListener('click', () => { if (!startButton.disabled) socket.emit('start_simulation'); }); stopButton.addEventListener('click', () => { if (!stopButton.disabled) socket.emit('stop_simulation'); }); resetRoundButton.addEventListener('click', () => { if (!resetRoundButton.disabled) socket.emit('reset_round'); }); resetFullButton.addEventListener('click', () => { if (!resetFullButton.disabled) socket.emit('reset_full'); }); applyParamsButton.addEventListener('click', () => { if (!applyParamsButton.disabled) { const configToSend = getUIConfig(); socket.emit('update_config', { config: configToSend }); } }); saveParamsButton.addEventListener('click', () => { if (!saveParamsButton.disabled) saveParamsToLocalStorage(); }); loadParamsButton.addEventListener('click', () => { if (!loadParamsButton.disabled) loadParamsFromLocalStorage(); }); resetParamsButton.addEventListener('click', () => { if (!resetParamsButton.disabled) resetParamsToDefault(); }); joinButton.addEventListener('click', () => { if (!joinButton.disabled) socket.emit('join_game'); }); leaveButton.addEventListener('click', () => { if (!leaveButton.disabled) socket.emit('leave_game'); }); }
        function addChatMessage(botId, message) { if (!chatContainerEl) return; const messageEl = document.createElement('div'); messageEl.classList.add('chat-message'); let botTypeClass = ''; if (clientState.bots[botId]) { const type = clientState.bots[botId].type; if (type === 'Learning') botTypeClass = clientState.bots[botId].is_player ? 'pl-color' : 'ln-color'; else if (type === 'Hardcoded') botTypeClass = 'hc-color'; } messageEl.innerHTML = `<strong class="${botTypeClass}">${botId}:</strong> ${message}`; chatContainerEl.appendChild(messageEl); while (chatContainerEl.childNodes.length > MAX_CHAT_MESSAGES + 1) { if(chatContainerEl.childNodes[1]) chatContainerEl.removeChild(chatContainerEl.childNodes[1]); } chatContainerEl.scrollTop = chatContainerEl.scrollHeight; }
        window.addEventListener('load', () => { disableAllControls(); setupSocket(); setupButtonListeners(); });
        let resizeTimeout; window.addEventListener('resize', () => { clearTimeout(resizeTimeout); resizeTimeout = setTimeout(() => { if (visualizer && clientState.environment) { try { visualizer.updateGridDimensions(clientState.environment.size); visualizer.update(clientState); } catch(e){ console.error("Resize error:", e); } } }, 150); });
    </script>
</body>
</html>

